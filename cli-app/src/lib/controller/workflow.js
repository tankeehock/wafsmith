import { TestBusinessTraffic, TestSinglePayload } from "../tester/tester.js";
import {
  CreateModSecurityRules,
  AggregateModSecurityRules,
  ClassifyLogs,
} from "../llm/agent.js";
import {
  TeardownTestingEnviornment,
  DeployTestingEnviornment,
  RedeployCRSContainer,
  WriteModSecurityRuleFile,
  DeleteModSecurityRuleFile,
  ValidateModSecurityRuleInExistingContainers,
  CheckNGINXServiceStatus
} from "../tester/deployment.js";
import { UpdateModSecRuleId, RemoveDuplicateRules } from "../../utils/utility.js";
import { TestPayloads } from "../tester/tester.js";
import { PrintToConsole } from "../../utils/utility.js";
import { COLORS, LOG_CLASSIFICATION, } from "../../utils/constants.js";
import { WriteLinesToFile, GetPercentageDisplay} from "../../utils/utility.js";
import { AGGREGATE_SYSTEM_PROMPT_1 } from "../llm/prompts/aggregate.js";
import OpenAI from "openai";
import ora from "ora";

export async function GenerateOpenAIClient(openAPIEndpoint, token, prompt, model) {
  return {
    model: model,
    client: new OpenAI({ apiKey: token, baseURL: openAPIEndpoint }),
    conversationHistory: [{ role: "system", content: prompt }],
  };
}

export function GenerateWorkflowClient(openAPIEndpoint, token, prompt, model) {
  return {
    model: model,
    openAPIEndpoint: openAPIEndpoint,
    token: token,
    systemPrompt: prompt,
  };
}

export async function RuleGenerationWorkflow(
  workflowCLient,
  infraDirectory,
  businessTraffic,
  payloads,
  method,
  position,
  outputFile,
  evadedFile,
  numberOfThreads
) {
  let step = 1;
  let totalSteps = 4;
  let generatorTracker = {};
  let fullRuleSet = [];
  let evadedPayloadsForOptimizedRuleset = [];
  let totalNumberOfEventualEvasion = 0;
  let spinner = null;
  PrintToConsole(`\nModsecurity Rule(s) Generation Workflow`, COLORS.BLUE);
  try {
    let proceed = false;
    let numberOfSuccessfulGeneration = 0;
    spinner = ora(`Attempting to generate ModSecurity rule(s) for ${payloads.length} payloads`).start();
    // Generate modsecurity rule for each payload
    let generatedRules = await CreateModSecurityRules(
      workflowCLient,
      payloads,
      method,
      position,
      numberOfThreads
    );
    // Format the data store
    for (let i = 0; i < generatedRules.length; i++) {
      // update rule Id
      let generatedRule = generatedRules[i];
      if (generatedRule.rule != null) {
        numberOfSuccessfulGeneration++;
        generatedRule.rule = await UpdateModSecRuleId(generatedRule.rule);
      }
      generatorTracker[generatedRule.payload] = {
        payload_test_status: false,
        traffic_simulation_test_status: false,
        rule: generatedRule.rule,
      };
      if (proceed == false && generatedRule.rule != null) {
        proceed = true;
      }
    }
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Generated ${numberOfSuccessfulGeneration} rule(s)`, COLORS.BLUE);
    // if no valid modsecurity rule generated, return
    if (proceed == false) {
      PrintToConsole(`No valid modsecurity rule(s) generated for given list of payload(s). Will proceed to exit.`, COLORS.YELLOW);
      return;
    }
    // Deploy testing environment
    spinner = ora(`Deploying Testing Enviornment`).start();
    await DeployTestingEnviornment(infraDirectory);
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Deployed testing enviornment`, COLORS.BLUE);
    spinner = ora(`Testing modsecurity rule(s) 0/${payloads.length}`).start();
    for (let i = 0; i < payloads.length; i++) {
      let payload = payloads[i];
      let modSecurityRule = generatorTracker[payload]["rule"];
      if (modSecurityRule == null) {
        spinner.text = `Skipping test for ${payload} since no valid modsecurity rule(s) generated by AI agent.`;
        continue;
      } else {
        spinner.text = `Testing modsecurity rule(s) generated for ${payload} - ${i + 1}/${payloads.length}`;
      }
      // Write the rule into the docker container and redeploy the container
      let filePath = await WriteModSecurityRuleFile(infraDirectory, modSecurityRule);
      await RedeployCRSContainer(infraDirectory);
      // let isValidRule = await ValidateModSecurityRuleInExistingContainers(infraDirectory, modSecurityRule);
      let isValidModSecurityRule = await CheckNGINXServiceStatus(infraDirectory);
      if (isValidModSecurityRule) {
        // A valid rule will allow the container to run
        let payloadTestResult = await TestSinglePayload(
          payload,
          position,
          method
        );
        generatorTracker[payload].payload_test_status = payloadTestResult;
        let businessTrafficTestResult = await TestBusinessTraffic(
          businessTraffic,
          position,
          method,
          numberOfThreads
        );
        
        generatorTracker[payload].traffic_simulation_test_status = businessTrafficTestResult;
      } else {
        generatorTracker[payload].payload_test_status = false;
        generatorTracker[payload].traffic_simulation_test_status = false;
      }
      // Delete the deployed modsecurity rule file and restart the container
      await DeleteModSecurityRuleFile(filePath);
      await RedeployCRSContainer(infraDirectory); // might consider removing this as it slows the program
    }
    spinner.stop();

    let numberOfSuccessfulRuleCreation = 0;
    let successfullyCreatedRules = [];
    let unsuccessfulPayloads = [];
    for (let payload in generatorTracker) {
      // only add if the rule is correct and fufills all testing conditions
      if (generatorTracker[payload].rule != null && generatorTracker[payload].payload_test_status && generatorTracker[payload].traffic_simulation_test_status) {
        numberOfSuccessfulRuleCreation++;
        successfullyCreatedRules.push(generatorTracker[payload].rule);
      } else {
        unsuccessfulPayloads.push(payload);
      }
    }

    PrintToConsole(`[${step++}/${totalSteps}] Completed testing of ${generatedRules.length} generated Modsecurity rule(s) - ${numberOfSuccessfulRuleCreation} passed`, COLORS.BLUE);
    if (numberOfSuccessfulRuleCreation > 2) {
      // consider spliting the chunks into at most 100 rules per processing batch
      // aggregating rules only make sense if there is 2 or more rule
      // attempt to aggregate rule
      let openAIClient = await GenerateOpenAIClient(workflowCLient.openAPIEndpoint, workflowCLient.token, AGGREGATE_SYSTEM_PROMPT_1, workflowCLient.model);
      spinner = ora("Aggregating rules").start();
      let optimizedRules = await AggregateModSecurityRules(openAIClient, successfullyCreatedRules.join("\n"), businessTraffic.join("\n"));
      spinner.stop();
      PrintToConsole(`[${step++}/${totalSteps}] Completed aggregation of rules`, COLORS.BLUE);
      spinner = ora("Validating syntax of generated rules").start();
      let optimizedValidRules = []
      for (let i = 0; i < optimizedRules.length; i++) {
        let rule = await UpdateModSecRuleId(optimizedRules[i]);
        // Docker Containers msut be running!
        let isValidRule = await ValidateModSecurityRuleInExistingContainers(infraDirectory, rule);
        if (isValidRule) {
          optimizedValidRules.push(rule);
        }
      }
      spinner.stop();
      let optimizedRuleSetResults = await OrchestrateRulesTesting(infraDirectory, optimizedValidRules, payloads, businessTraffic, method, position, numberOfThreads);
      // Decommission the testing enviornment
      spinner = ora("Decommissioning testing enviornment").start();
      await TeardownTestingEnviornment(infraDirectory);
      spinner.stop();
      PrintToConsole(`[${step++}/${totalSteps}] Decommissioned testing enviornment`, COLORS.BLUE);
      if (optimizedRuleSetResults != null) {
        if (optimizedRuleSetResults.business_traffic_test_status) {
          PrintToConsole(`\nBusiness Traffic Simulation Status (Aggregated Rules): passed`, COLORS.GREEN);
        } else {
          PrintToConsole(`\nBusiness Traffic Simulation Status (Aggregated Rules): failed`, COLORS.RED);
        }

        // Check for performance of the new rulesets
        if ("200" in optimizedRuleSetResults.data && optimizedRuleSetResults.data["200"].length > 0) {
          PrintToConsole(`\nNumber of payloads evaded optimized ruleset: ${optimizedRuleSetResults.data["200"].length}`, COLORS.YELLOW);
          PrintToConsole(`Will attempt to merge back previous rules to increase protection coverage`, COLORS.YELLOW);
        } else {
          PrintToConsole(`\nNumber of payloads evaded optimized ruleset: 0`, COLORS.GREEN);
        }
        fullRuleSet = [...fullRuleSet, ...optimizedValidRules];
        // Identify payloads that evaded the optimized rules and add the corresponding previously generated single rule (if any) to the final set
        if ("200" in optimizedRuleSetResults.data && optimizedRuleSetResults.data["200"].length > 0) {
          for (let i = 0; i < optimizedRuleSetResults.data["200"].length; i++) {
            let payload = optimizedRuleSetResults.data["200"][i];
            if ((generatorTracker[payload].rule == null) || generatorTracker[payload].payload_test_status == false || generatorTracker[payload].traffic_simulation_test_status == false ) {
              evadedPayloadsForOptimizedRuleset.push(payload);
              totalNumberOfEventualEvasion++;
            } else {
              fullRuleSet.push(generatorTracker[payload].rule);
            }
          }
        }
        // There is a potential case in which the duplicated rules were added back to the final set
        fullRuleSet = await RemoveDuplicateRules(fullRuleSet);
      } else {
        // Aggregation failed
        PrintToConsole(`\nAggregation of rules have failed`, COLORS.YELLOW);
        evadedPayloadsForOptimizedRuleset = unsuccessfulPayloads;
        totalNumberOfEventualEvasion = unsuccessfulPayloads.length;
        fullRuleSet = [...fullRuleSet, ...successfullyCreatedRules];
      }
    } else {
        PrintToConsole(`\nAggregation of rules was not performed`, COLORS.YELLOW);
        // Aggregation is not performed
        evadedPayloadsForOptimizedRuleset = unsuccessfulPayloads;
        totalNumberOfEventualEvasion = unsuccessfulPayloads.length;
        fullRuleSet = [...fullRuleSet, ...successfullyCreatedRules];
    }

    if (totalNumberOfEventualEvasion == 0) {
      PrintToConsole(`\nGenerated ${fullRuleSet.length} rules which blocked ${payloads.length - totalNumberOfEventualEvasion} out of ${payloads.length}.`, COLORS.GREEN);
      for (let i = 0; i < fullRuleSet.length; i++) {
        PrintToConsole(fullRuleSet[i], COLORS.GREEN);
      }
    } else {
      PrintToConsole(`\nGenerated ${fullRuleSet.length} rules which blocked ${payloads.length - totalNumberOfEventualEvasion} out of ${payloads.length}.`, COLORS.YELLOW);
      for (let i = 0; i < fullRuleSet.length; i++) {
        PrintToConsole(fullRuleSet[i], COLORS.YELLOW);
      }
    }

    if (fullRuleSet.length > 0 && outputFile) {
      WriteLinesToFile(outputFile, fullRuleSet);
      PrintToConsole(`\nWritten successfully created rule(s) to ${outputFile}`, COLORS.DEFAULT);
    }
    if (evadedPayloadsForOptimizedRuleset.length > 0) {
      WriteLinesToFile(evadedFile, evadedPayloadsForOptimizedRuleset);
      PrintToConsole(`Written payload(s) that failed rule generation to ${evadedFile}`, COLORS.DEFAULT);
    }
  } catch (err) {
    if (spinner != undefined || spinner != null) {
      spinner.stop();
    }
    PrintToConsole(`Fatal Error - will proceed to exit!`, COLORS.RED);
    PrintToConsole(err.message, COLORS.RED);
    PrintToConsole(err.stack, COLORS.RED);
    return;
  }
}

// Check if it closes safely
export async function RulesAggregationWorkflow(
  workflowClient,
  infraDirectory,
  rules,
  businessTraffic,
  payloads,
  method,
  position,
  outputFile,
  evadedFile,
  threads
) {
  let step = 1;
  let totalSteps = 3;
  let spinner = null;
  PrintToConsole(`Modsecurity Rule(s) Aggregation Workflow`, COLORS.BLUE);
  try {
    let spinner = ora(`Aggregating ModSecurity Rule(s)...`).start();
    let openAIClient = await GenerateOpenAIClient(
      workflowClient.openAPIEndpoint,
      workflowClient.token,
      AGGREGATE_SYSTEM_PROMPT_1,
      workflowClient.model
    );
    let optimizedRules = await AggregateModSecurityRules(
      openAIClient,
      rules.join("\n"),
      businessTraffic.join("\n")
    );
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Aggregated ${optimizedRules.length} ModSecurity Rule(s) successfully`, COLORS.BLUE);
    spinner = ora(`Deploying Testing Enviornment`).start();
    await DeployTestingEnviornment(infraDirectory);
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Deployed testing enviornment`, COLORS.BLUE);
    spinner = ora("Validating aggregated rules...").start();
    let optimizedValidRules = [];
    for (let i = 0; i < optimizedRules.length; i++) {
      let rule = optimizedRules[i];
      let isValidRule = await ValidateModSecurityRuleInExistingContainers(infraDirectory, rule);
      if (isValidRule) {
        optimizedValidRules.push(rule);
      }
    }
    spinner.text = "Testing aggregated rules..."
    let resultStore = await OrchestrateRulesTesting(infraDirectory, optimizedValidRules, payloads, businessTraffic, method, position, threads);
    await TeardownTestingEnviornment(infraDirectory);
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Decommissioned testing enviornment`, COLORS.BLUE);
    if (resultStore.business_traffic_test_status) {
      PrintToConsole(`\nBusiness Traffic Simulation Status: passed`, COLORS.GREEN);
    } else {
      PrintToConsole(`\nBusiness Traffic Simulation Status: failed`, COLORS.RED);
    }
    if ("200" in resultStore.data && resultStore.data["200"].length > 0) {
      PrintToConsole(`Aggregated ${rules.length} into ${optimizedValidRules.length} rule(s)`, COLORS.YELLOW);
      PrintToConsole(`Number of payloads blocked: ${resultStore.total - resultStore.data["200"].length}/${resultStore.total}`, COLORS.YELLOW);
      WriteLinesToFile(evadedFile, resultStore.data["200"]);
      PrintToConsole(`Written successfully evaded payloads to ${evadedFile}`, COLORS.DEFAULT);
    } else if (!("200" in resultStore.data)) {
      PrintToConsole(`Aggregated ${rules.length} into ${optimizedValidRules.length} rule(s)`, COLORS.RED);
      PrintToConsole(`Number of payloads blocked: 0/${resultStore.total}`, COLORS.RED);
      PrintToConsole(`Written successfully evaded payloads to ${evadedFile}`, COLORS.DEFAULT);
    }
    else {
      PrintToConsole(`\nAggregated ${rules.length} into ${optimizedValidRules.length} rule(s)`, COLORS.GREEN);
      PrintToConsole(`\nNumber of payloads blocked: ${resultStore.total}/${resultStore.total}`, COLORS.GREEN);
    }
    
    if (optimizedValidRules.length > 0) {
      WriteLinesToFile(outputFile, optimizedValidRules);
      PrintToConsole(`Written successfully aggregated rule(s) to ${outputFile}`, COLORS.DEFAULT);
    }
  } catch (err) {
    if (spinner != undefined || spinner != null) {
      spinner.stop();
    }

    PrintToConsole(`Fatal Error - will proceed to exit!`, COLORS.RED);
    PrintToConsole(err.message, COLORS.RED);
    PrintToConsole(err.stack, COLORS.RED);

  }
}

export async function EvaluateWorkflow(
  infraDirectory,
  payloads,
  businessTraffic,
  position,
  method,
  evadedFile,
  threads
) {
  let step = 1;
  let totalSteps = 3;
  let spinner = null;
  PrintToConsole(`\nTest ModSecurity Rule(s) Workflow`, COLORS.BLUE);
  try {
    // Deploy testing environment
    spinner = ora(`Deploying Testing Enviornment`).start();
    await DeployTestingEnviornment(infraDirectory);
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Deployed testing enviornment`, COLORS.BLUE);
    spinner = ora(`Testing payloads`).start();
    let payloadTestingResults = await TestPayloads(
      payloads,
      position,
      method,
      threads
    );
    // Simulate business traffic
    spinner.text = `Simulating business traffic`;
    let traffic_simulation_test_status = "yet-to-test";
    let businessTrafficTestResult = await TestBusinessTraffic(
      businessTraffic,
      position,
      method,
      threads
    );
    if (businessTrafficTestResult === true) {
      traffic_simulation_test_status = "passed";
    } else {
      traffic_simulation_test_status = "failed";
    }
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Completed testing of payloads`, COLORS.BLUE);
    spinner = ora("Decommissioning testing enviornment").start();
    await TeardownTestingEnviornment(infraDirectory);
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Completed decommissioning of testing enviornment`, COLORS.BLUE);
    if (traffic_simulation_test_status == "passed") {
      PrintToConsole(`\nBusiness Traffic Simulation Status: ${traffic_simulation_test_status}`, COLORS.GREEN);
    } else if (traffic_simulation_test_status == "yet-to-test") {
      PrintToConsole(`\nBusiness Traffic Simulation Status: ${traffic_simulation_test_status}`, COLORS.YELLOW);
    } else {
      PrintToConsole(`\nBusiness Traffic Simulation Status: ${traffic_simulation_test_status}`, COLORS.RED);
    }
    if ("200" in payloadTestingResults.data && payloadTestingResults.data["200"].length == payloadTestingResults.total) {
      PrintToConsole(`Evaded Payload(s): ${payloadTestingResults.data["200"].length}/${payloadTestingResults.total} (${GetPercentageDisplay(payloadTestingResults.data["200"].length, payloadTestingResults.total)}%)`, COLORS.RED);
      WriteLinesToFile(evadedFile, payloadTestingResults.data["200"]);
      PrintToConsole(`Written evaded payloads to to ${evadedFile}`, COLORS.DEFAULT);
    } else if ("200" in payloadTestingResults.data) {
      PrintToConsole(`Evaded Payload(s): ${payloadTestingResults.data["200"].length}/${payloadTestingResults.total} (${GetPercentageDisplay(payloadTestingResults.data["200"].length, payloadTestingResults.total)}%)`, COLORS.YELLOW);;
      WriteLinesToFile(evadedFile, payloadTestingResults.data["200"]);
      PrintToConsole(`Written evaded payloads to to ${evadedFile}`, COLORS.DEFAULT);
    } else {
      PrintToConsole(`Evaded Payload(s): 0/${payloadTestingResults.total} (${GetPercentageDisplay(0, payloadTestingResults.total)}%)`, COLORS.GREEN);
    }
  
  } catch (err) {
    if (spinner != undefined || spinner != null) {
      spinner.stop();
    }
    PrintToConsole(`Fatal Error - will proceed to exit!`, COLORS.RED);
    PrintToConsole(err.message, COLORS.RED);
    PrintToConsole(err.stack, COLORS.RED);
  }
}

export async function PayloadExtractionWorkflow(workflowClient, logs, outputFile, threads) {
  let step = 1;
  let totalSteps = 2;
  let spinner = null;
  PrintToConsole(`Payload Extraction Workflow`, COLORS.BLUE);
  try {
    let spinner = ora(`Extracting suspicious payloads`).start();
    let logsClassifications = await ClassifyLogs(workflowClient, logs, threads);
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Completed classifying ${logsClassifications.length} logs from AI agent`, COLORS.BLUE);
    spinner = ora(`Processing log classifications...`).start();
    let payloads = [];
    for (let i = 0; i < logsClassifications.length; i++) {
      spinner.text = `Processing ${i + 1}/${logsClassifications.length} log classifications`;
      let logClassification = logsClassifications[i];
      if (logClassification != null && logClassification.classification.classification != LOG_CLASSIFICATION.NON_MALICIOUS) {
        payloads.push(logClassification.classification.extracted_payload);
      }
    }
    spinner.stop();
    PrintToConsole(`[${step++}/${totalSteps}] Completed processing of log classifications from AI agent`, COLORS.BLUE);
    if (payloads.length > 0) {
      PrintToConsole(`\nExtracted ${payloads.length} payloads out of ${logs.length} entries`, COLORS.GREEN);
      WriteLinesToFile(outputFile, payloads);
      PrintToConsole(`\nWritten successfully payloads to ${outputFile}`, COLORS.DEFAULT);
    }

  } catch (err) {
    if (spinner != undefined || spinner != null) {
      spinner.stop();
    }
    PrintToConsole(`Fatal Error - will proceed to exit!`, COLORS.RED);
    PrintToConsole(err.message, COLORS.RED);
    PrintToConsole(err.stack, COLORS.RED);
  }
}

export async function OrchestrateRulesTesting(
  infraDirectory,
  rules,
  payloads,
  traffic,
  method,
  position,
  threads
) {
  let spinner = ora("Orchestrating Rule(s) Testing").start()
  // Deploy rules
  // Write the rule into the docker container and redeploy the container
  let filePath = await WriteModSecurityRuleFile(
    infraDirectory,
    rules.join("\n")
  );
  await RedeployCRSContainer(infraDirectory);
  let isContainerRunning = await CheckNGINXServiceStatus(infraDirectory);
  let payloadResultsStore = null;
  if (isContainerRunning) {
    // Test Rules
    payloadResultsStore = await TestPayloads(
      payloads,
      position,
      method,
      threads
    );
    payloadResultsStore["business_traffic_test_status"] = await TestBusinessTraffic(traffic, position, method, threads);
  }
  // Tear down enviornment
  // Delete the deployed modsecurity rule file
  await DeleteModSecurityRuleFile(filePath);
  await RedeployCRSContainer(infraDirectory);
  spinner.stop()
  return payloadResultsStore;
}
